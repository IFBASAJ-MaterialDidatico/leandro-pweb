import{_ as d,r,o as n,c,d as o,a,e as i,b as e}from"./app.57def927.js";const m={},u=i('<h1 id="a-evolucao-da-arquitetura-de-software" tabindex="-1"><a class="header-anchor" href="#a-evolucao-da-arquitetura-de-software" aria-hidden="true">#</a> A evolu\xE7\xE3o da Arquitetura de Software</h1><p><sup class="footnote-ref"><a href="#footnote1">[1]</a><a class="footnote-anchor" id="footnote-ref1"></a></sup></p>',2),l=i('<p>Logo no nascimento da tecnologia, quando come\xE7aram a serem constru\xEDdas as primeiras solu\xE7\xF5es automatizadas, a constru\xE7\xE3o de software era t\xE3o simples que a tarefa de abstra\xE7\xE3o e defini\xE7\xE3o de sua arquitetura era raramente realizada.</p><p>Com o surgimento das aplica\xE7\xF5es multicamadas, as varia\xE7\xF5es com as quais estas solu\xE7\xF5es poderiam ser concebidas come\xE7aram a crescer exponencialmente. Departamentos de tecnologia respons\xE1veis pela constru\xE7\xE3o come\xE7aram a se preocupar e a reconhecer a necessidade da cria\xE7\xE3o de um modelo de aplica\xE7\xE3o que poderia servir como base para todas as outras. Este modelo poderia definir a natureza das aplica\xE7\xF5es, como: tecnologia, padr\xF5es, regras, limita\xE7\xF5es e caracter\xEDsticas de design que seriam aplic\xE1veis a todas as solu\xE7\xF5es baseadas neste template. Isto marcou o nascimento da arquitetura de aplica\xE7\xE3o, tamb\xE9m conhecida como arquitetura de software.</p><p>O n\xEDvel de controle da arquitetura de aplica\xE7\xE3o pode ser diferente dependendo de cada corpora\xE7\xE3o. Algumas mant\xEAm um n\xEDvel mais alto, provendo abstra\xE7\xF5es f\xEDsicas e l\xF3gicas de um modelo de desenvolvimento, enquanto outras incluem informa\xE7\xF5es mais detalhadas, como modelos de dados, diagramas de fluxos de comunica\xE7\xF5es e requisitos de seguran\xE7a. Este modelo mais detalhado e espec\xEDfico pode ser mais comum em empresas que adotam diferentes especifica\xE7\xF5es de tecnologias, como Java EE e .Net. Por esta raz\xE3o, quando existir mais de uma especifica\xE7\xE3o de arquitetura de aplica\xE7\xE3o dentro de uma organiza\xE7\xE3o, existe a necessidade de manter o alinhamento atrav\xE9s da governan\xE7a estabelecida pela arquitetura corporativa.</p><h2 id="arquitetura-client-server-em-uma-camada" tabindex="-1"><a class="header-anchor" href="#arquitetura-client-server-em-uma-camada" aria-hidden="true">#</a> Arquitetura Client-Server em uma camada</h2><p>O in\xEDcio da utiliza\xE7\xE3o da computa\xE7\xE3o para automa\xE7\xE3o de processos aconteceu por meio dos grandes computadores, os mainframes. E com eles, a origem da arquitetura, onde todos os aspectos (apresenta\xE7\xE3o, regras de neg\xF3cio e dados) se localizavam na mesma camada. O mainframe servia a thin-clients, clientes que n\xE3o possu\xEDam qualquer responsabilidade, m\xE1quinas popularmente conhecidas como \u201Cterminais-burros\u201D. Seu \xFAnico papel era possibilitar o acesso ao mainframe, representando a \xFAnica camada que detinha todas as responsabilidades. Esta abordagem arquitet\xF4nica est\xE1 ilustrada na Figura 1.</p><p>Figura 1. Arquitetura Client-Server de uma camada no in\xEDcio da computa\xE7\xE3o com mainframes.</p><p>Esta arquitetura Client-Server foi gradativamente sendo abandonada quando uma varia\xE7\xE3o da mesma em duas camadas surgiu no final dos anos 80.</p><h2 id="arquitetura-client-server-em-duas-camadas" tabindex="-1"><a class="header-anchor" href="#arquitetura-client-server-em-duas-camadas" aria-hidden="true">#</a> Arquitetura Client-Server em duas camadas</h2><p>Esta nova forma de design introduziu o conceito de delega\xE7\xE3o de responsabilidades para as esta\xE7\xF5es cliente. Responsabilidades como processamento de l\xF3gica foram atribu\xEDdas para o lado do cliente, nascendo ent\xE3o o fat-client, tamb\xE9m conhecido como thick-client. Estes s\xE3o os clientes mais robustos, incorporados de mais responsabilidades dentro da abordagem de arquitetura.</p><p>Nesta arquitetura os clientes (fat-clients) possuem uma responsabilidade maior quanto ao processamento da l\xF3gica de aplica\xE7\xE3o e apresenta\xE7\xE3o. As esta\xE7\xF5es cliente foram impulsionadas principalmente pelo avan\xE7o da interface gr\xE1fica do usu\xE1rio (GUI \u2013 Graphical User Interface). Este tipo de cliente dominou o mundo de TI no in\xEDcio da d\xE9cada de 90. Na Figura 2 \xE9 ilustrada a estrutura em duas camadas para este modelo.</p><p>Figura 2. Arquitetura Client-Server em duas camada na evolu\xE7\xE3o da arquitetura de software.</p><p>A configura\xE7\xE3o comum desta arquitetura consistia em m\xFAltiplos fat-clients, cada um deles possuindo sua pr\xF3pria conex\xE3o de dados com o servidor central. O servidor, por sua vez, detinha escal\xE1veis sistemas de RDBMs (bases de dados relacionais) com alguma l\xF3gica de aplica\xE7\xE3o. Este tipo de arquitetura de software \xE9 caracterizado por aplica\xE7\xF5es monol\xEDticas que controlam e definem a forma como o usu\xE1rio interage com as aplica\xE7\xF5es.</p><p>Uma das desvantagens desta arquitetura era a exist\xEAncia de uma conex\xE3o de base de dados por usu\xE1rio. Conex\xF5es de base de dados eram dispendiosas por natureza, e causavam uma lat\xEAncia de processamento aos usu\xE1rios. Al\xE9m disso, as aplica\xE7\xF5es do lado do cliente tendiam a ser robustas e oneravam com um pesado processamento e armazenamento das regras da aplica\xE7\xE3o as suas esta\xE7\xF5es de trabalho. Havia ainda a dificuldade de manuten\xE7\xE3o tanto evolutiva como corretiva, pois todas estas esta\xE7\xF5es deveriam ser individualmente atualizadas no caso de uma necessidade de manuten\xE7\xE3o.</p><p>Outra caracter\xEDstica desta arquitetura de aplica\xE7\xE3o monol\xEDtica \xE9 a transfer\xEAncia de parte da l\xF3gica de aplica\xE7\xE3o para a base de dados, inserida em Stored Procedures e Triggers, e isto criava um alto acoplamento da solu\xE7\xE3o com a tecnologia.</p><h2 id="arquitetura-client-server-em-multiplas-camadas" tabindex="-1"><a class="header-anchor" href="#arquitetura-client-server-em-multiplas-camadas" aria-hidden="true">#</a> Arquitetura Client-Server em m\xFAltiplas camadas</h2><p>O pr\xF3ximo passo da evolu\xE7\xE3o da arquitetura em resposta aos custos e limita\xE7\xF5es com a Client-Server em duas camadas, foi a cria\xE7\xE3o de m\xFAltiplas camadas na divis\xE3o das responsabilidades, caracterizando ainda mais um modelo distribu\xEDdo. Juntamente com esta inova\xE7\xE3o, o conceito de aplica\xE7\xF5es baseadas em componentes chegou ao mundo da arquitetura de sofware, quebrando em partes as aplica\xE7\xF5es monol\xEDticas, formando componentes compat\xEDveis com o paradigma da orienta\xE7\xE3o a objetos.</p><p>A distribui\xE7\xE3o da l\xF3gica de aplicac\xE3o em m\xFAltiplos componentes (alguns no cliente, outros no servidor) facilitou o processo de instala\xE7\xE3o, centralizando grande parte da l\xF3gica nos servidores. Componentes de servidores agora se localizam em Servidores de Aplica\xE7\xE3o dedicados, que t\xEAm a miss\xE3o de controlar e disponibilizar recursos, como por exemplo, o pool de conex\xF5es com a base de dados, aliviando a onera\xE7\xE3o da cria\xE7\xE3o e acesso concorrente a estes objetos. Desta forma, uma \xFAnica conex\xE3o poderia facilmente servir a m\xFAltiplos clientes. A Figura 3 representa graficamente esta nova evolu\xE7\xE3o de arquitetura.</p><p>Figura 3. Arquitetura Client-Server em m\xFAltiplas camadas, o advento da componentiza\xE7\xE3o.</p><p>Como sempre, as vantagens v\xEAm acompanhadas com desvantagens, e aplicando este modelo de arquitetura, alguns problemas foram resolvidos, mas outros surgiram. O custo neste caso foi o aumento da complexidade, que impactava o desenvolvimento, implanta\xE7\xE3o e administra\xE7\xE3o das aplica\xE7\xF5es. Ao inv\xE9s da comunica\xE7\xE3o distribu\xEDda via conex\xE3o com a base de dados, surgiram novos meios de comunica\xE7\xE3o conhecidos como RPC (Remote Procedure Call), tais como CORBA e DCOM. Estas tecnologias possibilitaram a comunica\xE7\xE3o remota entre os componentes que residiam nos servidores e esta\xE7\xF5es cliente.</p><p>Este modelo de arquitetura em m\xFAltiplas camadas se caracteriza pelo surgimento da camada do meio, comumente denominada como middleware. Assim, o esfor\xE7o de manuten\xE7\xE3o se elevou, e servidores de aplica\xE7\xF5es ganharam significativamente mais aten\xE7\xE3o e relev\xE2ncia em ambientes maiores.</p><p>At\xE9 esse momento, as tecnologias da Web ainda n\xE3o faziam parte desse tipo de arquitetura. Foi no final da d\xE9cada de 90 que estas tecnologias se tornaram mais vi\xE1veis e come\xE7aram a ser incorporadas em solu\xE7\xF5es que seguiam a arquitetura Client-Server em m\xFAltiplas camadas.</p><p>O evento mais significante foi a substitui\xE7\xE3o dos componentes de softwares customizados das esta\xE7\xF5es cliente por navegadores (browsers). Este evento, al\xE9m de mudar e limitar radicalmente o design da interface de usu\xE1rio, moveu praticamente 100% da l\xF3gica de aplica\xE7\xE3o para o servidor.</p><h2 id="arquitetura-web-distribuida" tabindex="-1"><a class="header-anchor" href="#arquitetura-web-distribuida" aria-hidden="true">#</a> Arquitetura Web distribu\xEDda</h2><p>Esta arquitetura apresenta praticamente a mesma estrutura da arquitetura anterior, por\xE9m, com o advento das tecnologias Web, as camadas foram impactadas gerando altera\xE7\xF5es quanto \xE0 responsabilidade contida em cada uma. Isso alterou a abordagem realizada na estrutura\xE7\xE3o do software. Na Figura 4 podemos verificar como ficou esta estrutura\xE7\xE3o.</p><p>Figura 4. Arquitetura Web distribu\xEDda, o in\xEDcio do uso das tecnologias de Internet na arquitetura.</p><p>Com este novo modelo houve a introdu\xE7\xE3o de um novo componente importante e bem conhecido, o Servidor Web, que poderia formar, por si s\xF3, uma camada. Isto mudou a comunica\xE7\xE3o entre servidores e esta\xE7\xF5es cliente, passando de protocolos RPC propriet\xE1rios (CORBA, DCOM) para o protocolo da World Wide Web, o conhecido HTTP. O protocolo RPC se tornou mais utilizado na comunica\xE7\xE3o entre servidores Web remotos e Servidores de Aplica\xE7\xE3o.</p><p>Com exce\xE7\xE3o de algumas tecnologias propriet\xE1rias que estendem as funcionalidades dos navegadores, a maioria das solu\xE7\xF5es deste modelo de arquitetura coloca toda a l\xF3gica da aplica\xE7\xE3o no lado do servidor. At\xE9 mesmo as regras de apresenta\xE7\xE3o escritas em linguagens como JavaScript residem no servidor, e s\xE3o baixadas para o usu\xE1rio na primeira requisi\xE7\xE3o HTTP, centralizando toda a solu\xE7\xE3o no servidor.</p><p>A \xEAnfase maior deste modelo de arquitetura est\xE1 em defini\xE7\xF5es tais como:</p><ul><li>Estruturar como a aplica\xE7\xE3o vai ser particionada;</li><li>A responsabilidade de cada uma destas parti\xE7\xF5es, e;</li><li>De que forma elas ir\xE3o interagir entre si.</li></ul><p>Em uma perspectiva estrutural, a arquitetura web distribu\xEDda \xE9 muito semelhante \xE0 arquitetura orientada a servi\xE7os. Por exemplo: a l\xF3gica \xE9 provida pelo servidor e se encontra segmentada em componentes l\xF3gicos. A diferen\xE7a est\xE1 nos princ\xEDpios estabelecidos. Para compor a arquitetura web distribu\xEDda, a solu\xE7\xE3o se restringe nas tr\xEAs defini\xE7\xF5es anteriormente enfatizadas, enquanto que no SOA h\xE1 mais considera\xE7\xF5es a serem abordadas, como todos os princ\xEDpios que definem a cria\xE7\xE3o de servi\xE7os que permitam um ambiente ser orientado por eles.</p><p>Do final da d\xE9cada de 90 at\xE9 a metade da primeira d\xE9cada dos anos 2000, a arquitetura web distribu\xEDda representou de fato a arquitetura padr\xE3o para o desenvolvimento de solu\xE7\xF5es corporativas.</p><p>Esta arquitetura continua em constante evolu\xE7\xE3o, conforme novas tecnologias surgem e possibilitam pensar de forma diferente alguns detalhes. Como exemplo, tecnologias que possibilitam a constru\xE7\xE3o de Interfaces de Usu\xE1rio mais ricas, com mais din\xE2mica e poder de processamento, fazem com que a camada de apresenta\xE7\xE3o tenha mais relev\xE2ncia na separa\xE7\xE3o de responsabilidade entre as camadas. H\xE1 tamb\xE9m tecnologias que envolvem novas formas de comunica\xE7\xE3o entre as camadas, como: AJAX, JSON, REST e WebSocket. Este \xFAltimo tem um conceito novo que pode, no futuro, impactar mais forte as solu\xE7\xF5es de arquitetura, pois se trata de um protocolo bidirecional que permite que a comunica\xE7\xE3o entre o navegador e servidor Web seja iniciada tanto pelo navegador quanto pelo pr\xF3prio servidor Web, representando um canal aberto de dupla dire\xE7\xE3o de comunica\xE7\xE3o.</p>',32),p={href:"https://www.juliobattisti.com.br/artigos/windows7/anexo/07.asp",target:"_blank",rel:"noopener noreferrer"},v=e("No princ\xEDpio, um modelo Centralizado baseado no Mainframe"),f=e(":"),b=a("hr",null,null,-1),g=a("h2",{id:"referencias",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#referencias","aria-hidden":"true"},"#"),e(" Refer\xEAncias")],-1),h=a("hr",{class:"footnotes-sep"},null,-1),q={class:"footnotes"},_={class:"footnotes-list"},A={id:"footnote1",class:"footnote-item"},w=e("Ualter Devmedia. Orienta\xE7\xE3o a SOA! "),x={href:"https://www.devmedia.com.br/orientacao-a-soa/26551",target:"_blank",rel:"noopener noreferrer"},E=e("https://www.devmedia.com.br/orientacao-a-soa/26551"),z=e(". (Acessado em 18/06/2022) "),C=a("a",{href:"#footnote-ref1",class:"footnote-backref"},"\u21A9\uFE0E",-1);function S(O,W){const t=r("Mermaid"),s=r("ExternalLinkIcon");return n(),c("div",null,[u,o(t,{id:"mermaid-1a962850",code:"flowchart%20TB%0A%20%20%20%20c1--%3Ea2%0A%20%20%20%20subgraph%20one%0A%20%20%20%20a1--%3Ea2%0A%20%20%20%20end%0A%20%20%20%20subgraph%20two%0A%20%20%20%20b1--%3Eb2%0A%20%20%20%20end%0A%20%20%20%20subgraph%20three%0A%20%20%20%20c1--%3Ec2%0A%20%20%20%20end%0A%20%20%20%20one%20--%3E%20two%0A%20%20%20%20three%20--%3E%20two%0A%20%20%20%20two%20--%3E%20c2%0A"}),l,a("p",null,[a("a",p,[v,o(s)]),f]),b,g,h,a("section",q,[a("ol",_,[a("li",A,[a("p",null,[w,a("a",x,[E,o(s)]),z,C])])])])])}var N=d(m,[["render",S],["__file","Aula01.html.vue"]]);export{N as default};
